/* tslint:disable */
/* eslint-disable */
/**
 * M&A Earn-out API
 * # M&A Earn-out Management API  This API powers a decentralized M&A earn-out tracking and settlement system built on **Sui blockchain**, **Walrus decentralized storage**, and **Seal encryption**.  ## System Overview  The system enables buyers (acquirers), sellers, and auditors to: - Create and manage earn-out agreements on-chain - Store encrypted financial documents on Walrus - Track KPIs and verify calculations transparently - Execute settlements automatically based on audited KPIs  ## Technology Stack  - **Blockchain**: Sui Network (smart contracts in Move) - **Storage**: Walrus (decentralized file storage) - **Encryption**: Seal (role-based access control) - **Frontend**: Next.js with @mysten/dapp-kit  ## Key Concepts  ### Deal An on-chain earn-out agreement with defined periods, KPI types, and payout formulas. Each deal has three roles: - **Buyer**: Creates deal, uploads data, proposes KPIs, executes settlements - **Seller**: Monitors progress, receives payouts - **Auditor**: Verifies data, attests KPIs  ### Period A time range (e.g., fiscal year) with specific KPI targets and earn-out formulas. Each period progresses through stages: 1. Data Collection (buyer uploads financial documents) 2. KPI Proposal (buyer proposes calculated KPI) 3. KPI Attestation (auditor verifies and approves) 4. Settlement (buyer executes payout to seller)  ### Walrus Blobs Encrypted financial documents stored on Walrus network. Access controlled by Seal policy on Sui blockchain.  ### KPI (Key Performance Indicator) Metrics like revenue, EBITDA, or custom metrics that determine earn-out amounts according to on-chain formulas.  ## Authentication  This API uses **Sui wallet signature-based authentication**. Every request must include: - `X-Sui-Address`: User\'s Sui wallet address - `X-Sui-Signature`: Base64-encoded signature of the timestamp message - `X-Sui-Signature-Message`: ISO timestamp that was signed (e.g., \"2025-11-20T10:30:45.123Z\")  Signatures expire after **5 minutes** to prevent replay attacks. Role-based access control is enforced on-chain via Sui smart contracts.  ## Workflow  1. **Setup**: Buyer creates deal and sets earn-out parameters 2. **Data Upload**: Buyer uploads encrypted financial docs to Walrus (via upload relay) 3. **KPI Proposal**: After period ends, buyer proposes KPI value 4. **Verification**: Auditor decrypts docs, verifies calculations, attests KPI 5. **Settlement**: Buyer executes settlement, funds transferred to seller  ## API Organization  - **Deal Management**: Create and manage earn-out deals - **Parameters**: Configure earn-out formulas and periods - **Walrus**: Upload relay for encrypted file storage - **Timeline**: View data submission history - **KPI Management**: Propose and attest KPIs - **Settlement**: Execute earn-out payments - **Dashboard**: Aggregated view of deal status 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DataTimelineResponse,
  ForbiddenError,
  NotFoundError,
  UnauthorizedError,
} from '../models/index';
import {
    DataTimelineResponseFromJSON,
    DataTimelineResponseToJSON,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    UnauthorizedErrorFromJSON,
    UnauthorizedErrorToJSON,
} from '../models/index';

export interface GetDataTimelineRequest {
    xSuiAddress: string;
    xSuiSignature: string;
    dealId: string;
    periodId?: string;
    dataType?: GetDataTimelineDataTypeEnum;
    startDate?: Date;
    endDate?: Date;
    limit?: number;
    offset?: number;
}

/**
 * TimelineApi - interface
 * 
 * @export
 * @interface TimelineApiInterface
 */
export interface TimelineApiInterface {
    /**
     * **Purpose**: View all Walrus blob uploads for a deal in chronological order  **Business Logic**: - Retrieves all blob references registered on-chain for this deal - Sorts chronologically by upload timestamp - Enriches with metadata (period names, uploader info, file types) - Supports filtering by period, data type, and date range - Provides pagination for large datasets  **Use Cases**: - **Buyer**: Review submission history and ensure completeness - **Seller**: Monitor that buyer is submitting data as promised - **Auditor**: Identify which documents are available for verification  **Sui Integration**: - Reads: Queries all Period.walrusBlobs arrays for this deal - Events: Reads BlobRegistered events from Sui event indexer - Caching: Results cached for 5 minutes, invalidated on new uploads  **Walrus Integration**: - Metadata: Shows blob IDs and sizes (not content) - Content: Blobs remain encrypted, viewable only after Seal decryption - Storage: All referenced blobs are stored on Walrus network  **Seal Integration**: - Access: Each blob\'s decryption controlled by earnout_seal_policy - Roles: Buyer/Seller/Auditor can request decryption keys - Policy: On-chain verification before key is released  **Access Control**: - Role: All deal participants (buyer, seller, auditor) - Public metadata: Timeline is visible to all participants - Private content: File content requires Seal decryption 
     * @summary Get chronological timeline of all data uploads for a deal
     * @param {string} xSuiAddress 
     * @param {string} xSuiSignature 
     * @param {string} dealId Deal ID
     * @param {string} [periodId] Filter by specific period
     * @param {'revenue_journal' | 'ebitda_report' | 'expense_report' | 'balance_sheet' | 'cash_flow' | 'kpi_calculation' | 'audit_report' | 'custom'} [dataType] Filter by data type
     * @param {Date} [startDate] Filter uploads after this date
     * @param {Date} [endDate] Filter uploads before this date
     * @param {number} [limit] Maximum number of entries to return
     * @param {number} [offset] Number of entries to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelineApiInterface
     */
    getDataTimelineRaw(requestParameters: GetDataTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataTimelineResponse>>;

    /**
     * **Purpose**: View all Walrus blob uploads for a deal in chronological order  **Business Logic**: - Retrieves all blob references registered on-chain for this deal - Sorts chronologically by upload timestamp - Enriches with metadata (period names, uploader info, file types) - Supports filtering by period, data type, and date range - Provides pagination for large datasets  **Use Cases**: - **Buyer**: Review submission history and ensure completeness - **Seller**: Monitor that buyer is submitting data as promised - **Auditor**: Identify which documents are available for verification  **Sui Integration**: - Reads: Queries all Period.walrusBlobs arrays for this deal - Events: Reads BlobRegistered events from Sui event indexer - Caching: Results cached for 5 minutes, invalidated on new uploads  **Walrus Integration**: - Metadata: Shows blob IDs and sizes (not content) - Content: Blobs remain encrypted, viewable only after Seal decryption - Storage: All referenced blobs are stored on Walrus network  **Seal Integration**: - Access: Each blob\'s decryption controlled by earnout_seal_policy - Roles: Buyer/Seller/Auditor can request decryption keys - Policy: On-chain verification before key is released  **Access Control**: - Role: All deal participants (buyer, seller, auditor) - Public metadata: Timeline is visible to all participants - Private content: File content requires Seal decryption 
     * Get chronological timeline of all data uploads for a deal
     */
    getDataTimeline(requestParameters: GetDataTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataTimelineResponse>;

}

/**
 * 
 */
export class TimelineApi extends runtime.BaseAPI implements TimelineApiInterface {

    /**
     * **Purpose**: View all Walrus blob uploads for a deal in chronological order  **Business Logic**: - Retrieves all blob references registered on-chain for this deal - Sorts chronologically by upload timestamp - Enriches with metadata (period names, uploader info, file types) - Supports filtering by period, data type, and date range - Provides pagination for large datasets  **Use Cases**: - **Buyer**: Review submission history and ensure completeness - **Seller**: Monitor that buyer is submitting data as promised - **Auditor**: Identify which documents are available for verification  **Sui Integration**: - Reads: Queries all Period.walrusBlobs arrays for this deal - Events: Reads BlobRegistered events from Sui event indexer - Caching: Results cached for 5 minutes, invalidated on new uploads  **Walrus Integration**: - Metadata: Shows blob IDs and sizes (not content) - Content: Blobs remain encrypted, viewable only after Seal decryption - Storage: All referenced blobs are stored on Walrus network  **Seal Integration**: - Access: Each blob\'s decryption controlled by earnout_seal_policy - Roles: Buyer/Seller/Auditor can request decryption keys - Policy: On-chain verification before key is released  **Access Control**: - Role: All deal participants (buyer, seller, auditor) - Public metadata: Timeline is visible to all participants - Private content: File content requires Seal decryption 
     * Get chronological timeline of all data uploads for a deal
     */
    async getDataTimelineRaw(requestParameters: GetDataTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataTimelineResponse>> {
        if (requestParameters.xSuiAddress === null || requestParameters.xSuiAddress === undefined) {
            throw new runtime.RequiredError('xSuiAddress','Required parameter requestParameters.xSuiAddress was null or undefined when calling getDataTimeline.');
        }

        if (requestParameters.xSuiSignature === null || requestParameters.xSuiSignature === undefined) {
            throw new runtime.RequiredError('xSuiSignature','Required parameter requestParameters.xSuiSignature was null or undefined when calling getDataTimeline.');
        }

        if (requestParameters.dealId === null || requestParameters.dealId === undefined) {
            throw new runtime.RequiredError('dealId','Required parameter requestParameters.dealId was null or undefined when calling getDataTimeline.');
        }

        const queryParameters: any = {};

        if (requestParameters.periodId !== undefined) {
            queryParameters['periodId'] = requestParameters.periodId;
        }

        if (requestParameters.dataType !== undefined) {
            queryParameters['dataType'] = requestParameters.dataType;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString().substring(0,10);
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substring(0,10);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xSuiAddress !== undefined && requestParameters.xSuiAddress !== null) {
            headerParameters['X-Sui-Address'] = String(requestParameters.xSuiAddress);
        }

        if (requestParameters.xSuiSignature !== undefined && requestParameters.xSuiSignature !== null) {
            headerParameters['X-Sui-Signature'] = String(requestParameters.xSuiSignature);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature-Message"] = this.configuration.apiKey("X-Sui-Signature-Message"); // SuiSignatureMessage authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature"] = this.configuration.apiKey("X-Sui-Signature"); // SuiSignature authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Address"] = this.configuration.apiKey("X-Sui-Address"); // SuiWalletAuth authentication
        }

        const response = await this.request({
            path: `/deals/{dealId}/timeline`.replace(`{${"dealId"}}`, encodeURIComponent(String(requestParameters.dealId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataTimelineResponseFromJSON(jsonValue));
    }

    /**
     * **Purpose**: View all Walrus blob uploads for a deal in chronological order  **Business Logic**: - Retrieves all blob references registered on-chain for this deal - Sorts chronologically by upload timestamp - Enriches with metadata (period names, uploader info, file types) - Supports filtering by period, data type, and date range - Provides pagination for large datasets  **Use Cases**: - **Buyer**: Review submission history and ensure completeness - **Seller**: Monitor that buyer is submitting data as promised - **Auditor**: Identify which documents are available for verification  **Sui Integration**: - Reads: Queries all Period.walrusBlobs arrays for this deal - Events: Reads BlobRegistered events from Sui event indexer - Caching: Results cached for 5 minutes, invalidated on new uploads  **Walrus Integration**: - Metadata: Shows blob IDs and sizes (not content) - Content: Blobs remain encrypted, viewable only after Seal decryption - Storage: All referenced blobs are stored on Walrus network  **Seal Integration**: - Access: Each blob\'s decryption controlled by earnout_seal_policy - Roles: Buyer/Seller/Auditor can request decryption keys - Policy: On-chain verification before key is released  **Access Control**: - Role: All deal participants (buyer, seller, auditor) - Public metadata: Timeline is visible to all participants - Private content: File content requires Seal decryption 
     * Get chronological timeline of all data uploads for a deal
     */
    async getDataTimeline(requestParameters: GetDataTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataTimelineResponse> {
        const response = await this.getDataTimelineRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetDataTimelineDataTypeEnum = {
    RevenueJournal: 'revenue_journal',
    EbitdaReport: 'ebitda_report',
    ExpenseReport: 'expense_report',
    BalanceSheet: 'balance_sheet',
    CashFlow: 'cash_flow',
    KpiCalculation: 'kpi_calculation',
    AuditReport: 'audit_report',
    Custom: 'custom'
} as const;
export type GetDataTimelineDataTypeEnum = typeof GetDataTimelineDataTypeEnum[keyof typeof GetDataTimelineDataTypeEnum];
