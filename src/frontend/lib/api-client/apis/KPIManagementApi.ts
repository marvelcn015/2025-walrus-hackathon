/* tslint:disable */
/* eslint-disable */
/**
 * M&A Earn-out API
 * # M&A Earn-out Management API  This API powers a decentralized M&A earn-out tracking and settlement system built on **Sui blockchain**, **Walrus decentralized storage**, and **Seal encryption**.  ## System Overview  The system enables buyers (acquirers), sellers, and auditors to: - Create and manage earn-out agreements on-chain - Store encrypted financial documents on Walrus - Track KPIs and verify calculations transparently - Execute settlements automatically based on audited KPIs  ## Technology Stack  - **Blockchain**: Sui Network (smart contracts in Move) - **Storage**: Walrus (decentralized file storage) - **Encryption**: Seal (role-based access control) - **Frontend**: Next.js with @mysten/dapp-kit  ## Key Concepts  ### Deal An on-chain earn-out agreement with defined periods, KPI types, and payout formulas. Each deal has three roles: - **Buyer**: Creates deal, uploads data, proposes KPIs, executes settlements - **Seller**: Monitors progress, receives payouts - **Auditor**: Verifies data, attests KPIs  ### Period A time range (e.g., fiscal year) with specific KPI targets and earn-out formulas. Each period progresses through stages: 1. Data Collection (buyer uploads financial documents) 2. KPI Proposal (buyer proposes calculated KPI) 3. KPI Attestation (auditor verifies and approves) 4. Settlement (buyer executes payout to seller)  ### Walrus Blobs Encrypted financial documents stored on Walrus network. Access controlled by Seal policy on Sui blockchain.  ### KPI (Key Performance Indicator) Metrics like revenue, EBITDA, or custom metrics that determine earn-out amounts according to on-chain formulas.  ## Authentication  This API uses **Sui wallet signature-based authentication**. Every request must include: - `X-Sui-Address`: User\'s Sui wallet address - `X-Sui-Signature`: Base64-encoded signature of the timestamp message - `X-Sui-Signature-Message`: ISO timestamp that was signed (e.g., \"2025-11-20T10:30:45.123Z\")  Signatures expire after **5 minutes** to prevent replay attacks. Role-based access control is enforced on-chain via Sui smart contracts.  ## Workflow  1. **Setup**: Buyer creates deal and sets earn-out parameters 2. **Data Upload**: Buyer uploads encrypted financial docs to Walrus (via upload relay) 3. **KPI Proposal**: After period ends, buyer proposes KPI value 4. **Verification**: Auditor decrypts docs, verifies calculations, attests KPI 5. **Settlement**: Buyer executes settlement, funds transferred to seller  ## API Organization  - **Deal Management**: Create and manage earn-out deals - **Parameters**: Configure earn-out formulas and periods - **Walrus**: Upload relay for encrypted file storage - **Timeline**: View data submission history - **KPI Management**: Propose and attest KPIs - **Settlement**: Execute earn-out payments - **Dashboard**: Aggregated view of deal status 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AttestKPIRequest,
  AttestKPIResponse,
  ConflictError,
  ForbiddenError,
  NotFoundError,
  ProposeKPIRequest,
  ProposeKPIResponse,
  UnauthorizedError,
  ValidationError,
} from '../models/index';
import {
    AttestKPIRequestFromJSON,
    AttestKPIRequestToJSON,
    AttestKPIResponseFromJSON,
    AttestKPIResponseToJSON,
    ConflictErrorFromJSON,
    ConflictErrorToJSON,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    ProposeKPIRequestFromJSON,
    ProposeKPIRequestToJSON,
    ProposeKPIResponseFromJSON,
    ProposeKPIResponseToJSON,
    UnauthorizedErrorFromJSON,
    UnauthorizedErrorToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface AttestKPIOperationRequest {
    xSuiAddress: string;
    xSuiSignature: string;
    dealId: string;
    periodId: string;
    attestKPIRequest: AttestKPIRequest;
}

export interface ProposeKPIOperationRequest {
    xSuiAddress: string;
    xSuiSignature: string;
    dealId: string;
    periodId: string;
    proposeKPIRequest: ProposeKPIRequest;
}

/**
 * KPIManagementApi - interface
 * 
 * @export
 * @interface KPIManagementApiInterface
 */
export interface KPIManagementApiInterface {
    /**
     * **Purpose**: Auditor verifies and attests the buyer\'s proposed KPI  **Business Logic**: - Auditor reviews buyer\'s KPI proposal - Auditor decrypts and verifies supporting Walrus blobs using Seal - Auditor independently calculates KPI from source documents - If approved: Creates on-chain attestation with verified value - If rejected: Records rejection reason, buyer must re-propose  **Audit Verification Flow**: 1. Auditor sees KPI proposal from buyer 2. Auditor downloads blob IDs referenced in proposal 3. Auditor requests decryption keys from Seal (role-based access) 4. Seal verifies auditor role via earnout_seal_policy on Sui 5. Auditor decrypts and reviews actual financial documents 6. Auditor verifies calculations match proposal 7. Auditor signs attestation transaction  **Sui Integration**: - Writes: Calls `earnout::attest_kpi(deal, period, value, approved)` - Transaction: Returns unsigned transaction for auditor to sign - Events: Emits `KPIAttested` event with final verified value - State: Period.kpiAttestation updated, status → \"attested\" - Gas: Estimated ~1,800,000 MIST  **Seal Integration**: - Access: Auditor role allows blob decryption - Policy: earnout_seal_policy verifies auditor address on-chain - Verification: Auditor can decrypt all buyer-uploaded blobs  **Settlement Trigger**: - Once KPI is attested, period becomes eligible for settlement - Buyer can then call settlement endpoint to execute payout  **Access Control**: - Role: Auditor only - Verification: User address must match deal.auditor - Prerequisite: KPI must be proposed by buyer first 
     * @summary Auditor attests/approves KPI value
     * @param {string} xSuiAddress Auditor\&#39;s Sui address
     * @param {string} xSuiSignature 
     * @param {string} dealId 
     * @param {string} periodId 
     * @param {AttestKPIRequest} attestKPIRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KPIManagementApiInterface
     */
    attestKPIRaw(requestParameters: AttestKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AttestKPIResponse>>;

    /**
     * **Purpose**: Auditor verifies and attests the buyer\'s proposed KPI  **Business Logic**: - Auditor reviews buyer\'s KPI proposal - Auditor decrypts and verifies supporting Walrus blobs using Seal - Auditor independently calculates KPI from source documents - If approved: Creates on-chain attestation with verified value - If rejected: Records rejection reason, buyer must re-propose  **Audit Verification Flow**: 1. Auditor sees KPI proposal from buyer 2. Auditor downloads blob IDs referenced in proposal 3. Auditor requests decryption keys from Seal (role-based access) 4. Seal verifies auditor role via earnout_seal_policy on Sui 5. Auditor decrypts and reviews actual financial documents 6. Auditor verifies calculations match proposal 7. Auditor signs attestation transaction  **Sui Integration**: - Writes: Calls `earnout::attest_kpi(deal, period, value, approved)` - Transaction: Returns unsigned transaction for auditor to sign - Events: Emits `KPIAttested` event with final verified value - State: Period.kpiAttestation updated, status → \"attested\" - Gas: Estimated ~1,800,000 MIST  **Seal Integration**: - Access: Auditor role allows blob decryption - Policy: earnout_seal_policy verifies auditor address on-chain - Verification: Auditor can decrypt all buyer-uploaded blobs  **Settlement Trigger**: - Once KPI is attested, period becomes eligible for settlement - Buyer can then call settlement endpoint to execute payout  **Access Control**: - Role: Auditor only - Verification: User address must match deal.auditor - Prerequisite: KPI must be proposed by buyer first 
     * Auditor attests/approves KPI value
     */
    attestKPI(requestParameters: AttestKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AttestKPIResponse>;

    /**
     * **Purpose**: Buyer submits calculated KPI result after period ends  **Business Logic**: - Buyer calculates KPI from uploaded financial data - System validates period has ended - Formula from parameters used to calculate earn-out preview - Creates on-chain KPI proposal - Status changes to \"proposed\" (awaits auditor attestation)  **Sui Integration**: - Writes: Calls `earnout::propose_kpi(deal, period, value)` - Transaction: Returns unsigned transaction for buyer to sign - Events: Emits `KPIProposed` event with dealId, periodId, value - State: Period.kpiProposal updated with proposed value - Gas: Estimated ~1,500,000 MIST  **Calculation Preview**: - Backend pre-calculates earn-out amount using on-chain formula - Shows buyer the projected payout BEFORE signing transaction - Helps buyer verify KPI entry is correct  **Data References**: - Buyer can reference supporting Walrus blob IDs - These references are stored on-chain with the proposal - Auditor can later verify against same blobs  **Access Control**: - Role: Buyer only - Verification: User address must match deal.buyer - Timing: Period must have ended (endDate < now) - Status: Period must not already have attested KPI 
     * @summary Buyer proposes KPI value for a period
     * @param {string} xSuiAddress Buyer\&#39;s Sui address
     * @param {string} xSuiSignature 
     * @param {string} dealId 
     * @param {string} periodId Period identifier
     * @param {ProposeKPIRequest} proposeKPIRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KPIManagementApiInterface
     */
    proposeKPIRaw(requestParameters: ProposeKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProposeKPIResponse>>;

    /**
     * **Purpose**: Buyer submits calculated KPI result after period ends  **Business Logic**: - Buyer calculates KPI from uploaded financial data - System validates period has ended - Formula from parameters used to calculate earn-out preview - Creates on-chain KPI proposal - Status changes to \"proposed\" (awaits auditor attestation)  **Sui Integration**: - Writes: Calls `earnout::propose_kpi(deal, period, value)` - Transaction: Returns unsigned transaction for buyer to sign - Events: Emits `KPIProposed` event with dealId, periodId, value - State: Period.kpiProposal updated with proposed value - Gas: Estimated ~1,500,000 MIST  **Calculation Preview**: - Backend pre-calculates earn-out amount using on-chain formula - Shows buyer the projected payout BEFORE signing transaction - Helps buyer verify KPI entry is correct  **Data References**: - Buyer can reference supporting Walrus blob IDs - These references are stored on-chain with the proposal - Auditor can later verify against same blobs  **Access Control**: - Role: Buyer only - Verification: User address must match deal.buyer - Timing: Period must have ended (endDate < now) - Status: Period must not already have attested KPI 
     * Buyer proposes KPI value for a period
     */
    proposeKPI(requestParameters: ProposeKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProposeKPIResponse>;

}

/**
 * 
 */
export class KPIManagementApi extends runtime.BaseAPI implements KPIManagementApiInterface {

    /**
     * **Purpose**: Auditor verifies and attests the buyer\'s proposed KPI  **Business Logic**: - Auditor reviews buyer\'s KPI proposal - Auditor decrypts and verifies supporting Walrus blobs using Seal - Auditor independently calculates KPI from source documents - If approved: Creates on-chain attestation with verified value - If rejected: Records rejection reason, buyer must re-propose  **Audit Verification Flow**: 1. Auditor sees KPI proposal from buyer 2. Auditor downloads blob IDs referenced in proposal 3. Auditor requests decryption keys from Seal (role-based access) 4. Seal verifies auditor role via earnout_seal_policy on Sui 5. Auditor decrypts and reviews actual financial documents 6. Auditor verifies calculations match proposal 7. Auditor signs attestation transaction  **Sui Integration**: - Writes: Calls `earnout::attest_kpi(deal, period, value, approved)` - Transaction: Returns unsigned transaction for auditor to sign - Events: Emits `KPIAttested` event with final verified value - State: Period.kpiAttestation updated, status → \"attested\" - Gas: Estimated ~1,800,000 MIST  **Seal Integration**: - Access: Auditor role allows blob decryption - Policy: earnout_seal_policy verifies auditor address on-chain - Verification: Auditor can decrypt all buyer-uploaded blobs  **Settlement Trigger**: - Once KPI is attested, period becomes eligible for settlement - Buyer can then call settlement endpoint to execute payout  **Access Control**: - Role: Auditor only - Verification: User address must match deal.auditor - Prerequisite: KPI must be proposed by buyer first 
     * Auditor attests/approves KPI value
     */
    async attestKPIRaw(requestParameters: AttestKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AttestKPIResponse>> {
        if (requestParameters.xSuiAddress === null || requestParameters.xSuiAddress === undefined) {
            throw new runtime.RequiredError('xSuiAddress','Required parameter requestParameters.xSuiAddress was null or undefined when calling attestKPI.');
        }

        if (requestParameters.xSuiSignature === null || requestParameters.xSuiSignature === undefined) {
            throw new runtime.RequiredError('xSuiSignature','Required parameter requestParameters.xSuiSignature was null or undefined when calling attestKPI.');
        }

        if (requestParameters.dealId === null || requestParameters.dealId === undefined) {
            throw new runtime.RequiredError('dealId','Required parameter requestParameters.dealId was null or undefined when calling attestKPI.');
        }

        if (requestParameters.periodId === null || requestParameters.periodId === undefined) {
            throw new runtime.RequiredError('periodId','Required parameter requestParameters.periodId was null or undefined when calling attestKPI.');
        }

        if (requestParameters.attestKPIRequest === null || requestParameters.attestKPIRequest === undefined) {
            throw new runtime.RequiredError('attestKPIRequest','Required parameter requestParameters.attestKPIRequest was null or undefined when calling attestKPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSuiAddress !== undefined && requestParameters.xSuiAddress !== null) {
            headerParameters['X-Sui-Address'] = String(requestParameters.xSuiAddress);
        }

        if (requestParameters.xSuiSignature !== undefined && requestParameters.xSuiSignature !== null) {
            headerParameters['X-Sui-Signature'] = String(requestParameters.xSuiSignature);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature-Message"] = this.configuration.apiKey("X-Sui-Signature-Message"); // SuiSignatureMessage authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature"] = this.configuration.apiKey("X-Sui-Signature"); // SuiSignature authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Address"] = this.configuration.apiKey("X-Sui-Address"); // SuiWalletAuth authentication
        }

        const response = await this.request({
            path: `/deals/{dealId}/periods/{periodId}/kpi/attest`.replace(`{${"dealId"}}`, encodeURIComponent(String(requestParameters.dealId))).replace(`{${"periodId"}}`, encodeURIComponent(String(requestParameters.periodId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AttestKPIRequestToJSON(requestParameters.attestKPIRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttestKPIResponseFromJSON(jsonValue));
    }

    /**
     * **Purpose**: Auditor verifies and attests the buyer\'s proposed KPI  **Business Logic**: - Auditor reviews buyer\'s KPI proposal - Auditor decrypts and verifies supporting Walrus blobs using Seal - Auditor independently calculates KPI from source documents - If approved: Creates on-chain attestation with verified value - If rejected: Records rejection reason, buyer must re-propose  **Audit Verification Flow**: 1. Auditor sees KPI proposal from buyer 2. Auditor downloads blob IDs referenced in proposal 3. Auditor requests decryption keys from Seal (role-based access) 4. Seal verifies auditor role via earnout_seal_policy on Sui 5. Auditor decrypts and reviews actual financial documents 6. Auditor verifies calculations match proposal 7. Auditor signs attestation transaction  **Sui Integration**: - Writes: Calls `earnout::attest_kpi(deal, period, value, approved)` - Transaction: Returns unsigned transaction for auditor to sign - Events: Emits `KPIAttested` event with final verified value - State: Period.kpiAttestation updated, status → \"attested\" - Gas: Estimated ~1,800,000 MIST  **Seal Integration**: - Access: Auditor role allows blob decryption - Policy: earnout_seal_policy verifies auditor address on-chain - Verification: Auditor can decrypt all buyer-uploaded blobs  **Settlement Trigger**: - Once KPI is attested, period becomes eligible for settlement - Buyer can then call settlement endpoint to execute payout  **Access Control**: - Role: Auditor only - Verification: User address must match deal.auditor - Prerequisite: KPI must be proposed by buyer first 
     * Auditor attests/approves KPI value
     */
    async attestKPI(requestParameters: AttestKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AttestKPIResponse> {
        const response = await this.attestKPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * **Purpose**: Buyer submits calculated KPI result after period ends  **Business Logic**: - Buyer calculates KPI from uploaded financial data - System validates period has ended - Formula from parameters used to calculate earn-out preview - Creates on-chain KPI proposal - Status changes to \"proposed\" (awaits auditor attestation)  **Sui Integration**: - Writes: Calls `earnout::propose_kpi(deal, period, value)` - Transaction: Returns unsigned transaction for buyer to sign - Events: Emits `KPIProposed` event with dealId, periodId, value - State: Period.kpiProposal updated with proposed value - Gas: Estimated ~1,500,000 MIST  **Calculation Preview**: - Backend pre-calculates earn-out amount using on-chain formula - Shows buyer the projected payout BEFORE signing transaction - Helps buyer verify KPI entry is correct  **Data References**: - Buyer can reference supporting Walrus blob IDs - These references are stored on-chain with the proposal - Auditor can later verify against same blobs  **Access Control**: - Role: Buyer only - Verification: User address must match deal.buyer - Timing: Period must have ended (endDate < now) - Status: Period must not already have attested KPI 
     * Buyer proposes KPI value for a period
     */
    async proposeKPIRaw(requestParameters: ProposeKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProposeKPIResponse>> {
        if (requestParameters.xSuiAddress === null || requestParameters.xSuiAddress === undefined) {
            throw new runtime.RequiredError('xSuiAddress','Required parameter requestParameters.xSuiAddress was null or undefined when calling proposeKPI.');
        }

        if (requestParameters.xSuiSignature === null || requestParameters.xSuiSignature === undefined) {
            throw new runtime.RequiredError('xSuiSignature','Required parameter requestParameters.xSuiSignature was null or undefined when calling proposeKPI.');
        }

        if (requestParameters.dealId === null || requestParameters.dealId === undefined) {
            throw new runtime.RequiredError('dealId','Required parameter requestParameters.dealId was null or undefined when calling proposeKPI.');
        }

        if (requestParameters.periodId === null || requestParameters.periodId === undefined) {
            throw new runtime.RequiredError('periodId','Required parameter requestParameters.periodId was null or undefined when calling proposeKPI.');
        }

        if (requestParameters.proposeKPIRequest === null || requestParameters.proposeKPIRequest === undefined) {
            throw new runtime.RequiredError('proposeKPIRequest','Required parameter requestParameters.proposeKPIRequest was null or undefined when calling proposeKPI.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSuiAddress !== undefined && requestParameters.xSuiAddress !== null) {
            headerParameters['X-Sui-Address'] = String(requestParameters.xSuiAddress);
        }

        if (requestParameters.xSuiSignature !== undefined && requestParameters.xSuiSignature !== null) {
            headerParameters['X-Sui-Signature'] = String(requestParameters.xSuiSignature);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature-Message"] = this.configuration.apiKey("X-Sui-Signature-Message"); // SuiSignatureMessage authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Signature"] = this.configuration.apiKey("X-Sui-Signature"); // SuiSignature authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Sui-Address"] = this.configuration.apiKey("X-Sui-Address"); // SuiWalletAuth authentication
        }

        const response = await this.request({
            path: `/deals/{dealId}/periods/{periodId}/kpi/propose`.replace(`{${"dealId"}}`, encodeURIComponent(String(requestParameters.dealId))).replace(`{${"periodId"}}`, encodeURIComponent(String(requestParameters.periodId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProposeKPIRequestToJSON(requestParameters.proposeKPIRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProposeKPIResponseFromJSON(jsonValue));
    }

    /**
     * **Purpose**: Buyer submits calculated KPI result after period ends  **Business Logic**: - Buyer calculates KPI from uploaded financial data - System validates period has ended - Formula from parameters used to calculate earn-out preview - Creates on-chain KPI proposal - Status changes to \"proposed\" (awaits auditor attestation)  **Sui Integration**: - Writes: Calls `earnout::propose_kpi(deal, period, value)` - Transaction: Returns unsigned transaction for buyer to sign - Events: Emits `KPIProposed` event with dealId, periodId, value - State: Period.kpiProposal updated with proposed value - Gas: Estimated ~1,500,000 MIST  **Calculation Preview**: - Backend pre-calculates earn-out amount using on-chain formula - Shows buyer the projected payout BEFORE signing transaction - Helps buyer verify KPI entry is correct  **Data References**: - Buyer can reference supporting Walrus blob IDs - These references are stored on-chain with the proposal - Auditor can later verify against same blobs  **Access Control**: - Role: Buyer only - Verification: User address must match deal.buyer - Timing: Period must have ended (endDate < now) - Status: Period must not already have attested KPI 
     * Buyer proposes KPI value for a period
     */
    async proposeKPI(requestParameters: ProposeKPIOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProposeKPIResponse> {
        const response = await this.proposeKPIRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
